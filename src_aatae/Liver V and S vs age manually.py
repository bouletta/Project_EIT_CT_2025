import os
import pandas as pd
import numpy as np
import nibabel as nib
from skimage import measure
import matplotlib.pyplot as plt
import seaborn as sns
from nibabel.affines import apply_affine  

#To adapt
data_dir=r'C:\Users\boulette\OneDrive\Bureau\Stage\Data_set'
meta_csv=r'C:\Users\boulette\OneDrive\Bureau\Stage\meta.csv'
organ_name="liver.nii.gz"

meta_df=pd.read_csv(meta_csv, sep=";")
meta_df.set_index("image_id", inplace=True)

results=[]
for subject in sorted(os.listdir(data_dir)):
    subject_dir=os.path.join(data_dir, subject)
    seg_path=os.path.join(subject_dir, "segmentations", organ_name)

    if not os.path.exists(seg_path):
        continue

    try:
        img=nib.load(seg_path)
        data=img.get_fdata()
        affine=img.affine  
        verts,faces,_,_=measure.marching_cubes(data, level=0.5) # verts: points of the 3D reconstruction. faces : triangles connecting the points verts.Exemple: The triangle faces[0]=[12,3,2] is the triangle whos points are verts[12], verts[3],verts[2]

        verts_mm=apply_affine(affine, verts)     #does conversion to RAS values then affine transformation.

        v1=verts_mm[faces[:,1]]-verts_mm[faces[:,0]]
        v2=verts_mm[faces[:,2]]-verts_mm[faces[:,0]]              
        triangle_areas=0.5*np.linalg.norm(np.cross(v1,v2), axis=1)     #   surface of a traingle generated by vectors v1 and v2 : S=0.5* || v1 * v2 ||, then sum all the the surfaces
        surface_cm2=np.sum(triangle_areas)/100  

        volume=0.0
        for tri in faces:
            a=verts_mm[tri[0]]
            b=verts_mm[tri[1]]                 # expression used : V=1/6 * OA * OB *OC for a triangle ABC.Not sure come back later. 
            c=verts_mm[tri[2]]
            volume+=np.dot(a,np.cross(b, c))
        volume_cm3=abs(volume)/6.0/1000





        if subject in meta_df.index:
            age=meta_df.loc[subject,"age"]
            gender=meta_df.loc[subject,"gender"]
            results.append({"subject":subject,"age":age,"gender":gender,"volume_cm3":volume_cm3,"surface_cm2":surface_cm2})

    except Exception as e:            # Exception for unvalid cases,like here s0419 and s0454 livers' ,who seem not to be binary images
        print(f"Error processing{subject}:{e}")


df=pd.DataFrame(results)

##print(df[['volume_cm3','surface_cm2']])





sns.set(style="whitegrid")
plt.figure(figsize=(8, 6))
palette={"m": "blue", "f": "red"}
sns.scatterplot(data=df, x="age", y="volume_cm3", hue="gender", palette=palette)
stats = df.groupby("gender")["volume_cm3"].agg(["mean", "std"]).round(1)

y_max = df["volume_cm3"].max()
x_min = df["age"].min()

text_x = x_min + 1
text_y = y_max - 100

for i, gender in enumerate(["m", "f"]):
    if gender in stats.index:
        mean_val = stats.loc[gender, "mean"]
        std_val = stats.loc[gender, "std"]
        gender_name = "Male" if gender == "m" else "Female"
        color = palette[gender]
        plt.text(text_x, text_y - i*150, f"{gender_name}: mean = {mean_val} cm³\net = {std_val} cm³", 
                 color=color, fontsize=10, ha="left", va="top")

plt.title("Liver Volume (manual) vs Age")
plt.xlabel("Age")
plt.ylabel("Volume (cm³)")
plt.legend(title="Gender")
plt.tight_layout()
plt.show()







plt.figure(figsize=(8, 6))
sns.scatterplot(data=df, x="age", y="surface_cm2", hue="gender", palette={"m": "blue", "f": "red"})
stats = df.groupby("gender")["surface_cm2"].agg(["mean", "std"]).round(1)
y_max_surf = df["surface_cm2"].max()
x_min_surf = df["age"].min()
text_x = x_min_surf + 1
text_y = y_max_surf - 100
for i, gender in enumerate(["m", "f"]):
    if gender in stats.index:
        mean_val = stats.loc[gender, "mean"]
        std_val = stats.loc[gender, "std"]
        gender_name = "Male" if gender == "m" else "Female"
        color = palette[gender]
        plt.text(text_x, text_y - i*150, f"{gender_name}: mean = {mean_val} cm²\net = {std_val} cm²", 
                 color=color, fontsize=10, ha="left", va="top")

plt.title("Liver Surface Area (manual) vs Age")
plt.xlabel("Age")
plt.ylabel("Surface Area (cm²)")
plt.legend(title="Gender")
plt.tight_layout()
plt.show()